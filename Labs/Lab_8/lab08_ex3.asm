
.orig x3000
;=============
;Instructions;
;=============
	JSR SUB_PALINDROME	;jump to the subroutine palindrome
	JSR SUB_IS_PALINDROME	;jump to the subroutine palindrome
	ADD R4, R4, #0		;LEFT SHIFT

	BRp PRINT_IS_A_PALINDROME;IF YES THEN IS A PALINDROME
	BRnz PRINT_NOT_A_PALINDROME	;IF NO THEN ISNT A PALINDROME

	PRINT_IS_A_PALINDROME:	;PRINTING THE MSG YES
	LEA R0, IS_PALINDROME
	PUTS
	BR FINISH_TO_HALT	;GO TO HALT AFTER PRINTING

	PRINT_NOT_A_PALINDROME:	;PRINTING THE MSG NO
	LEA R0, NOT_PALINDROME
	PUTS
	BR FINISH_TO_HALT	;GO TO HALT AFTER PRINTING

FINISH_TO_HALT:		;HALT FUNCTION
	HALT


;==========
;Local data
;==========

	IS_PALINDROME	.STRINGZ "The string is a palindrome! \n"
	NOT_PALINDROME	.STRINGZ "The string is not a palindrome.\n"

;**********************************************************************************************

;====================
;GETTING STRING SUB
;====================
;COPIED FROM ASS 1
;===========
;SUBROUTINE;
;===========

.ORIG x3200
SUB_PALINDROME:

ST R7, BACKUP_R7
LEA R0, INTRO_MESSAGE
PUTS

LD R1, ARRAY_PTR

CIN_INPUT
  GETC			;GET THE INPUT
  OUT
STR R0,R1, #0
ADD R1, R1, #1
ADD R5, R5, #1
ADD R0, R0, #-10	;CHECK IF ENTER KEY
BRp CIN_INPUT		;LOOP BACK
ADD R5, R5, #-1
END_CIN_INPUT		;ELSE END IT


LD R7, BACKUP_R7

RET

;=====================
;DATA FOR FIRST SUB
;=====================
	INTRO_MESSAGE	.STRINGZ "Input a string followed by ENTER: "
	ARRAY_PTR .FILL x4000 ;TO MAKE FIRST CHAR BEGIN HERE
	BACKUP_R7 .FILL x0000

;**********************************************************************************************

;=====================
;SUB CHECK IF PALINDROME
;=====================
.orig x3400

SUB_IS_PALINDROME:
	ST R1, BACKUP_R1_3400
	ST R7, BACKUP_R7_3400

	LD R1, ARRAY_PTR_3400
	LD R2, BACKUP_R1_3400
	ADD R2, R2, #-2			;GET POINTER TO LAST CHAR
	LD R4, NUM_ZERO

	CHECK_CHARACTER		  	;STORE NUM IN X4000?

		LDR R5, R1, #0		;GET CHAR FROM FRONT AND BEACK
		LDR R6, R2, #0

		ADD R1, R1, #1		;INCREASE R1
		ADD R2, R2, #-1		;DECREASE R2
		NOT R3, R1		;NOT R1 INTO R3
		ADD R3, R3, #1		;INCREASE R3
		NOT R5, R5		;NOT R5 AND PUT IT BACK TO SEE IF REVERSED

		ADD R5, R5, #1
		ADD R0, R5, R6		;CEHCK IF R5 == R6
			BRnp IS_NOT_PALINDROME	;IF POS OR NEG THEN THE ELEMENTS DIDNT MATCH AND IT ISNT A P
			BRz FINISHING_FUNC		;IF 0 THEN THE ELEMENTS MATCHED AND IT IS A p

  FINISHING_FUNC:
        ADD R0, R2, R3 		;CHECK IF R0 HAS NEWLINE
        BRzp CHECK_CHARACTER
    END_CHECK_CHARACTER

	IS_A_PALINDROME:
	ADD R4, R4, #1
	LD R1, BACKUP_R1_3400
	LD R7, BACKUP_R7_3400
	RET

	IS_NOT_PALINDROME:
	LD R1, BACKUP_R1_3400
	LD R7, BACKUP_R7_3400

	RET

;=====================
;DATA FOR SECOND SUB
;=====================
	ARRAY_PTR_3400 .FILL x4000 	;FIRST CHAR OF STR BEGINS AT X4000 LIKE THE SPECS
	BACKUP_R7_3400 .FILL x0000	;DONT NEED TO FILL WITH ANYTHING AT THE BEGINNING
	BACKUP_R1_3400 .FILL x0000	;''	''	''	''	''	''	''
	NUM_ZERO 	.FILL #0	;0 NEEDS 0

;**********************************************************************************************

.ORIG x3600		;BECAUSE 3200 AND 3400 ARE TAKEN AND NEEDS TO BE IN INCREMENTS OF 200?
;============
;SPECIAL SUB
;============
ST R0, BACKUP_R0_3600
ST R1, BACKUP_R1_3600
ST R7, BACKUP_R7_3600

LD R1, NUM_0
LD R4, LABEL1

CHECK_UPPER_CHAR
  LDR R2, R0, #0
  ADD R3, R2, R1
  BRz FINISHING_FUNC2

  AND R2, R2, R4
  STR R2, R0, #0
  ADD R0, R0, #1

  BRnzp CHECK_UPPER_CHAR

FINISHING_FUNC2
  LD R0, BACKUP_R0_3600
  LD R1, BACKUP_R1_3600
  LD R7, BACKUP_R7_3600

  RET
;==========
;Subroutine Data
;=========
NUM_0 .FILL#0
LABEL1 .FILL x5F
BACKUP_R0_3600 .BLKW #1
BACKUP_R1_3600 .BLKW #1
BACKUP_R7_3600 .BLKW #1

.END