

.ORIG x3000

	LD R1,DEC_NUM
	AND R4,R4,#0

FIRST_LOOP
	GETC				;OUTPUT THE NUMBERS THAT USER INPUTS
	OUT	

	ADD R1,R1,#-1			;REDUCE R1
	ADD R2,R1,#-16			;MAKE R1 = TO THE 16 NUMS WE NEED
	ADD R2,R2,#0			;KEEP DOING THIS UNTIL 16 NUMS WE HAVE
	BRz FIRST_LOOP

	ADD R3,R1,#0

	LD R2,ASCII_NUM			;PUT THAT CONVERTED ASCII NUMBER INTO R2
	ADD R0,R0,R2			;PUT R2 INTO R0

TWO_LOOPP	
	ADD R3,R3,#0			;IF ZERO GO TO THE THIRD LOOP
	BRz THREE_LOOPP
	ADD R0,R0,R0			;SHIFT LEFT AND PUT BACK IN
	ADD R3,R3,#-1			;IF POSITIVE KEEP IN THIS LOOP
	BRp TWO_LOOPP

THREE_LOOPP
	ADD R4,R4,R0			;IF ZERO GO HERE
	ADD R1,R1,#0			;KEEP ASKING USER FOR OUTPUTS IF POSITIVE
	BRp FIRST_LOOP

	ADD R2,R4,#0
	ADD R1,R2,#0

	LD R5,toASCII			;PUT THE DEC TO ASCII INTO R5
	LD R3,SUB_ADDR
	LD R0,NEW_LINE2			;OUTPUT NEWLINE
	OUT

;JSRR R3 AND HALT?
	JSRR	R3

	HALT

;=======
;DATA;
;=======
	DEC_NUM		.FILL	#17
	ASCII_NUM		.FILL	#-48
	toASCII		.FILL	#48
	SUB_ADDR	.FILL	x5000
	NEW_LINE2	.FILL	#10

.ORIG x5000		;START SUB AT A LATER MEM
;====================
; ROLLING OUR SUBS XD
;====================
PRINT_SUBROUTINE
BACKUP_INIT
	ST R7,R7_BACKUP

	LD R6,DEC_16

PRINT_BRANCH	
	ADD R1,R1,#0
	BRzp ZERO_PRINT
	ADD R1,R1,#0
	BRn ONE_PRINT

WHATS_NEXT
	ADD R1,R1,R1
	ADD R6,R6,#-1

	LD R7,SPACE4
	ADD R7,R6,R7
	BRz PRINT_SPACE

	LD R7,SPACE8
	ADD R7,R6,R7
	BRz PRINT_SPACE

	LD R7,SPACE12
	ADD R7,R6,R7
	BRz PRINT_SPACE

PENULTIMATE_LOOPP
	ADD R6,R6,#0	
	BRp PRINT_BRANCH
	LD R0,NEW_LINE
	OUT
	BRnzp END_SUBROUTINE

ZERO_PRINT
	AND R0,R0,#0
	ADD R0,R0,R5
	OUT
	BRnzp WHATS_NEXT

ONE_PRINT	
	AND R0,R0,#0
	ADD R0,R0,#1
	ADD R0,R0,R5
	OUT
	BRnzp WHATS_NEXT

PRINT_SPACE
	LD R0,NEW_SPACE
	OUT
	BRnzp PENULTIMATE_LOOPP

END_SUBROUTINE
	LD R7,R7_BACKUP

	RET

;============
;REMOTE DATA
;============
	DEC_16		.FILL	#16

	SPACE4		.FILL	#-12		;TRIPLETS
	SPACE8		.FILL	#-8
	SPACE12		.FILL	#-4

	NEW_LINE	.FILL	#10		;TWINS
	NEW_SPACE	.FILL	#32
	
	R7_BACKUP	.FILL	x0		;BACKUP SINGERS


.END