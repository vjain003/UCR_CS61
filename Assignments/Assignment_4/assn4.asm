

.ORIG x3000			; Program begins here
;-------------
;Instructions
;-------------

;-------------------------------
;INSERT CODE STARTING FROM HERE 
;--------------------------------
;Example of how to Output Intro Message
;LD R0, introMessage  ;Output Intro Message
;PUTS
;Example of how to Output Error Message
;LD SR0, errorMessage  ;Output Error Message
;PUTS

AND R5,R5, #0
BR BEGINNING_FUNC

;CHECK IF ERROR
ERROR		;IF ERROR, PUT OUT THE NEW LINE AND THE ERROR MESSAGE
LD R0, NEW_LINE
OUT
LD R0, errorMessage
PUTS

AND R5, R5, #0
BEGINNING_FUNC
LD R0, introMessage		;OUTPUT THE INTRO MSG
PUTS
GETC				;GET THE INPUTS AND SHOW THEM AS WELL
OUT

;CHECK FOR POSITIVE INPUT. 
;IF 0 THEN TRUE --> IF 0 THEN P, 
;IF !0, CHECK FOR NEG
LD R1, INPUT_POS
ADD R3, R1, R0
BRz TRUE
BR CHECK_IF_NEG

;CHECK FOR NEGATIVE INPUT, 
;IF 0 THEN WE CHECK THE SIGN BC POS. ELSE CHECK THAT NUM
CHECK_IF_NEG
LD R1, INPUT_NEG
ADD R3, R1, R0
BRz CHECK_SIGN
BR INPUT_NUM1

;DOING 2S COMPLEMENT ON IT
CHECK_SIGN
LD R3, NUM_ONE
ST R3, NEG_MEM
BR TRUE

TRUE

GETC
OUT

;********TODO: REFER BACK TO NOTES
INPUT_NUM1
LD R3, INPUT_NINE
LD R4, MAX_NUM
ADD R5, R0, R3
BRp ERROR		;IF > 9 ITS AN ERROR. REFER BACK TO NOTES FOR MORE
LD R3, INPUT_ZERO
ADD R5, R0, R3
BRn ERROR
ST R5, MEM

ADD R4, R4, #-1		;COUNTER AND STORING THAT TOO. HERE TO SEE WHERE WE ARE
ST R4, MAX_NUM

LOOPP
LD R4, MAX_NUM
GETC
OUT
ADD R1, R0, #-10		;IF THE ENTER IS PRESSED GIVE NULL
BRz ENDL		;IF NOTHING LEFT, PRESS ENTER/GO TO ENTER
BR CHECK_NUM

ENDL
LD R2, NUM_ONE
ADD R2, R2, #-1
BRz CONVERTER

;CHECKING IF GREATER THAN 9 OR LESS THAN 0. ERROR IN BOTH
CHECK_NUM
LD R3, INPUT_NINE
LD R2, NUM_ONE
ST R2, MEM2
ADD R5, R0, R3
BRp ERROR		;IF GREATER THAN 9

LD R3, INPUT_ZERO
ADD R1, R0, R3
BRn ERROR		;IF LESS THAN 0

LD R5, MEM
ADD R2, R1, #0

LD R2, ENT
LD R6, NULL
ADD R5,R5, #0
BRz YES_ZERO
BR NO_ZERO

YES_ZERO
ADD R2, R2, #-10
NO_ZERO

LOOPP2
ADD R6,R6, R2
ADD R5, R5, #-1
BRp LOOPP2
ADD R6, R6, R1
ST R6, MEM
BR DONE

DONE
ADD R4, R4, #-1
ST R4, MAX_NUM
BRp LOOPP

CONVERTER
LD R5, MEM

LD R3, NEG_MEM
ADD R3,R3, #0		;LEFT SHIFT
BRnz FINISHING_FUNC

;2'S COMPLEMENT ON R5
NOT R5, R5		;MAKING IT ONES COMPELEMENT 
ADD R5, R5, #1		;MAKING IT 2'S OCMPLEMENT BY ADDING ONE

ST R2, NULL
ADD R2, R5, #0

FINISHING_FUNC

LD R0, NEW_LINE
OUT

HALT
;---------------	
;Data
;---------------
INPUT_ZERO	.FILL	#-48		;ASCIIS
INPUT_NINE	.FILL	#-57
NEW_LINE	.FILL	#10
INPUT_POS	.FILL	#-43
INPUT_NEG	.FILL	#-45
MAX_NUM		.FILL	#5		;BC CAN ONYL HAVE UPTO 5 DIGITS
NULL		.FILL	#0
NUM_ONE		.FILL 	#1
ENT		.FILL	#10

;INITIALIZE MEM, MEM2, AND THE NEG MEM WITH 0 FIRST SO IT DOESNT SKEW
;UPDATE: 0 DIDNT WORK SO WILL TRY 1. 
;UPDATE2: 1 WORKS
MEM	.BLKW	#1
MEM2	.BLKW	#1
NEG_MEM	.BLKW	#1

introMessage .FILL x6000
errorMessage .FILL x6100

;------------
;Remote data
;------------
.ORIG x6000
;---------------
;messages
;---------------
intro .STRINGZ	"Input a positive or negative decimal number (max 5 digits), followed by ENTER\n"
;---------------
;error_messages
;---------------
.ORIG x6100	
error_mes .STRINGZ	"ERROR INVALID INPUT\n"

;---------------
;END of PROGRAM
;---------------
.END
;-------------------
;PURPOSE of PROGRAM
;-------------------